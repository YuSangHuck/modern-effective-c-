- [ch5. 오른값 참조, 이동 의미론, 완벽 전달](#ch5-오른값-참조-이동-의미론-완벽-전달)
  - [그냥 사전지식?](#그냥-사전지식)
  - [item 23. std::move와 std::forward를 숙지하라](#item-23-stdmove와-stdforward를-숙지하라)
    - [1. move는 오른값으로 무조건 캐스팅한다. 이동하는게 아니다.](#1-move는-오른값으로-무조건-캐스팅한다-이동하는게-아니다)
    - [2. forward는 주어진 인수가 오른값에 묶인 경우에만, 오른값으로 캐스팅 한다.](#2-forward는-주어진-인수가-오른값에-묶인-경우에만-오른값으로-캐스팅-한다)
    - [3. move,forward 둘 다 싱핼시점에서는 아무일도 하지 않는다.](#3-moveforward-둘-다-싱핼시점에서는-아무일도-하지-않는다)
  - [item 24. 보편 참조와 오른값 참조를 구별하라](#item-24-보편-참조와-오른값-참조를-구별하라)
    - [1. 함수 템플릿 매개변수의 형식이 T\&\&이고, T가 연역된다면 또는 객체를 auto\&\&로 선언한다면 이는 보편참조이다.](#1-함수-템플릿-매개변수의-형식이-t이고-t가-연역된다면-또는-객체를-auto로-선언한다면-이는-보편참조이다)
    - [2. 형식선언의 형태가 정확히 형식\&\&가 아니면, 혹은 형식 연역이 일어나지 않는다면 이는 오른값참조다.](#2-형식선언의-형태가-정확히-형식가-아니면-혹은-형식-연역이-일어나지-않는다면-이는-오른값참조다)
    - [3. 오른값으로 초기화되는 보편참조는 오른값참조에 해당한다. 왼값으로 초기화되는 보편참조는 왼값참조에 해당한다.](#3-오른값으로-초기화되는-보편참조는-오른값참조에-해당한다-왼값으로-초기화되는-보편참조는-왼값참조에-해당한다)
  - [item 25. 오른값 참조에는 std::move를, 보편참조에는 std::forward를 사용하라](#item-25-오른값-참조에는-stdmove를-보편참조에는-stdforward를-사용하라)
    - [1. 오른값참조나 보편참조가 마지막으로 쓰이는 지점에서, 오른값참조에는 move를, 보편참조에는 forward를 사용하라](#1-오른값참조나-보편참조가-마지막으로-쓰이는-지점에서-오른값참조에는-move를-보편참조에는-forward를-사용하라)
    - [2. 결과를 값 전달하는 함수이고, 오른값참조,보편참조인 경우 move,forward를 사용하라](#2-결과를-값-전달하는-함수이고-오른값참조보편참조인-경우-moveforward를-사용하라)
    - [3. rvo가 적용될 수 있는 지역객체에는 move,forward를 적용하지 말라](#3-rvo가-적용될-수-있는-지역객체에는-moveforward를-적용하지-말라)
  - [item 26. 보편참조에 대한 중복적재를 피하라](#item-26-보편참조에-대한-중복적재를-피하라)
    - [1. 보편참조에 오버로딩의 빈번한 호출:보편참조를 사용한 오버로딩은 예상보다 자주 호출되는 상황으로 이어진다. 이는 보편참조 특성상 다양한 상황에서 매칭 될 가능성이 높기때문](#1-보편참조에-오버로딩의-빈번한-호출보편참조를-사용한-오버로딩은-예상보다-자주-호출되는-상황으로-이어진다-이는-보편참조-특성상-다양한-상황에서-매칭-될-가능성이-높기때문)
    - [2. 완벽전달생성자의 문제점:완벽전달생성자는 non-const 왼값에 대해 복사생성자보다 더 좋은 매칭이 된다. 이는 기본클래스의 복사,이동 생성자를 호출하려는 파생클래스의 생성자 호출을 가로챌 수 있는 문제가 있다. 완벽전달생성자가 기본클래스의 복사,이동 생성자보다 우선적으로 호출될 수 있어, 의도치 않은 동작을 유발 할 수 있다.](#2-완벽전달생성자의-문제점완벽전달생성자는-non-const-왼값에-대해-복사생성자보다-더-좋은-매칭이-된다-이는-기본클래스의-복사이동-생성자를-호출하려는-파생클래스의-생성자-호출을-가로챌-수-있는-문제가-있다-완벽전달생성자가-기본클래스의-복사이동-생성자보다-우선적으로-호출될-수-있어-의도치-않은-동작을-유발-할-수-있다)
  - [item 27. 보편참조에 대한 오버로딩 대신 사용할 수 있는 기법들을 알아두라](#item-27-보편참조에-대한-오버로딩-대신-사용할-수-있는-기법들을-알아두라)
    - [1. 보편참조와 오버로딩의 조합에 대한 대안으로는 구별되는 함수이름 사용, 매개변수를 const에 대한 좌측값 참조로 전달, 매개변수를 값으로 전달, 꼬리표 배분 사용 등이 있다.](#1-보편참조와-오버로딩의-조합에-대한-대안으로는-구별되는-함수이름-사용-매개변수를-const에-대한-좌측값-참조로-전달-매개변수를-값으로-전달-꼬리표-배분-사용-등이-있다)
    - [2. std::enable\_if 를 통해 템플릿의 인스턴스화를 제한함으로써 보편참조와 오버로딩을 함께 사용할 수 있다(std::enable\_if 는 컴파일러가 보편참조를 오버로딩하는 조건을 개발자가 직접 제어)](#2-stdenable_if-를-통해-템플릿의-인스턴스화를-제한함으로써-보편참조와-오버로딩을-함께-사용할-수-있다stdenable_if-는-컴파일러가-보편참조를-오버로딩하는-조건을-개발자가-직접-제어)
    - [3. 보편참조 매개변수는 효율성 면에서 장점인 경우가 많지만, 대체로 사용성 면에서는 단점이 된다.](#3-보편참조-매개변수는-효율성-면에서-장점인-경우가-많지만-대체로-사용성-면에서는-단점이-된다)
  - [item 30. 완벽전달이 실패하는 경우들을 잘 알아두라.](#item-30-완벽전달이-실패하는-경우들을-잘-알아두라)

# ch5. 오른값 참조, 이동 의미론, 완벽 전달

## 그냥 사전지식?

- 참조란?
  - alias, 포인터에 비해 메모리(주소저장)와 연산(주소연산)면에서 효율적
  - 수정가능성(alias이므로 원본 데이터)
  - null safe
- 오른값 참조란?
  - 말 그대로 오른값에 대한 참조로, 이동의미론과 완벽전달에 사용
  - 이동의미론은 복사대신 이동을 통한 효율성
  - 완벽전달은 인자를 완벽히 전달해 성능 및 유연성 유지
- 보편참조는?
  - 생긴건 오른값 참조처럼 &&지만, template, auto, ... 에 사용
  - lvalue, rvalue 모두 참조를 받을 수 있으므로 유연(완벽전달)
  - const vs non-const, volatile vs non-volatile 그냥 유연 그 자체
- lvalue, xvalue, rvalue
  - [참조](https://modoocode.com/294)
  - type과 value category가 있는데
  - 정체의 유무, 이동가능성으로 나눔
- 참조의 변환
  - const T&& -> const T& 가능(상수성 유지)

| x      | 이동 가능 | 이동불가능 |
| ------ | --------- | ---------- |
| 정체 o | xvalue    | lvalue     |
| 정체 x | pravlue   | 쓸모 없음  |

- decltype{표현식}은 함수처럼 쓰이고, 컴파일시 표현식에 대한 type을 반환한다
  - decltype(xavlue) -> T&&
  - decltype(lavlue) -> T&
  - decltype(ravlue) -> T

## item 23. std::move와 std::forward를 숙지하라

### 1. move는 오른값으로 무조건 캐스팅한다. 이동하는게 아니다.

- move(이동 의미론)
  - 1. 이동을 할 객체가 const면 복사하므로 이동을 보장하지않고, const로 선언하면 안된다.
    - `string(string&& rhs)`일 때, `Annotation(const std::string text): value(std::move(text)) { ... }` // string의 이동생성자가 존재할 때, text는 이동이 아닌 복사된다(const 정확성 유지를 위해)
      - text가 const 왼값이므로 std::move(text)는 const text의 오른값 참조를 반환
      - const 오른값 참조인데, 이동생성자는 오른값 참조이므로 이동생성자 호출 안됨
      - const 오른값 참조는 암시적으로 const 왼값 참조로 변환될 수 있으므로 복사생성자 호출
  - 2. 확실한건 반환값은 오른값 참조이긴 함(이동된 오른값 참조거나, 복사된 오른값 참조거나)

### 2. forward는 주어진 인수가 오른값에 묶인 경우에만, 오른값으로 캐스팅 한다.

- forward(move와 비슷하나 조건부 casting, 완벽 전달)
  - forward의 인수가 오른값으로 초기화 된 경우에만, 오른값으로 casting한다
  - 오른값으로 초기화 여부는 어떻게 아는가? 템플릿 매개변수에 부호화 되어있다.
  - **그러면 forward는 템플릿 함수 안에서만 쓸 수 있나? item28을 보자**

- 그러면 forward만 써도 되는가?
  - 가능은 하지만, 굳이? 명확성도 떨어지고 버그가능성도 높아지고?

### 3. move,forward 둘 다 싱핼시점에서는 아무일도 하지 않는다.

## item 24. 보편 참조와 오른값 참조를 구별하라

> 걍 두개 구분해라가 전부고
> 오른값참조는 이동을 위해(이동의 원본 객체 지정)
> 보편참조는 전달을 위해(전달의 원본 객체 지정?)

### 1. 함수 템플릿 매개변수의 형식이 T&&이고, T가 연역된다면 또는 객체를 auto&&로 선언한다면 이는 보편참조이다.

### 2. 형식선언의 형태가 정확히 형식&&가 아니면, 혹은 형식 연역이 일어나지 않는다면 이는 오른값참조다.

### 3. 오른값으로 초기화되는 보편참조는 오른값참조에 해당한다. 왼값으로 초기화되는 보편참조는 왼값참조에 해당한다.

- 오른값 참조
  - `void f(Widget&& param)`
  - `Widget&& var1 = Widget()`
  - `template<typename T> void f(std::vector<T>&& param)`
- 보편참조
  - `auto&& var2 = var1`
  - `template<typename T> void f(T&& param)`

- 오른값 참조
  - 이동의 원본이 될 수 있는 개체 지정
- 보편참조
  - 거의 항상 전달을 적용해야하므로 전달참조라고 부르기도 함
  - 초기값에 따라 왼값참조 혹은 오른값참조
  - 형식 연역이 일어나는 문맥이고, 단, T&& 형태여야만 한다
  - 형식연역은 호출타임에 일어난다(vector의 push_back은 이미 인스턴스화 된 시점에서 type이 고정임)

## item 25. 오른값 참조에는 std::move를, 보편참조에는 std::forward를 사용하라

- 이동 의미론과 move와 오른값참조 등장배경
  - 거대한 객체를 함수 전달시 복사는 비효율적
  - 이동이란 개념을 도입하자(move)
  - 오른값참조 등장!
- 완벽 전달과 forward와 보편참조 등장배경
  - 함수 템플릿에서 인자 전달시 원래 성질을 유지해야 함.
  - forward 이전에는 코드 복잡성 초래(std::conditional)
  - forward화 함께 보편참조 등장!

### 1. 오른값참조나 보편참조가 마지막으로 쓰이는 지점에서, 오른값참조에는 move를, 보편참조에는 forward를 사용하라

> todo: setname은 왜 보편참조를 인자로 받아야 하는가? 상수왼값참조만 있으면 되는거 아닌가? 왜 오른값 참조가 필요하지?
> 보편참조로 받으면 불필요한 복사비용을 줄일 수 있다. item 26에도 나옴

- 오른값참조를 다른 함수에 전달할 때는 move
- 보편참조를 다른 함수에 전달할 때는 forward
- forward 대신 move를 사용 할 수도 있지만, 관용적인 표현도 아니고 그렇게 해서 이득이 없다. 그냥 하지마라

- **setname은 왜 보편참조를 인자로 받아야 하는가? 상수왼값참조만 있으면 되는거 아닌가? 왜 오른값 참조가 필요하지?**
- 무튼 보편참조를 쓰면 3가지 장점
  - 유지보수 편함
  - 효율성(임시객체 생성 및 소멸)
  - 오른값일수도 왼값일수도 있는 매개변수가 무제한인 경우 overloading은 불가능. 오로지 보편참조
- move,forward로 다른 함수 인자로 주는 경우, 해당 객체를 다 쓰고 마지막에 줘야한다.

### 2. 결과를 값 전달하는 함수이고, 오른값참조,보편참조인 경우 move,forward를 사용하라

- 함수의 결과가 값을 반환한다면, move나 forward를 사용하는게 바람직하다(복사보단 이동이 낫다)

### 3. rvo가 적용될 수 있는 지역객체에는 move,forward를 적용하지 말라

- 단, 확대해석은 하지마라. move쓰면 RVO가 안되는 경우도 있다(Return Value Optimization)
  - 두가지 조건이 만족하면, 값을 반환하는 함수 호출시 복사 혹시 이동을 제거할 수 있다(copy elision)

## item 26. 보편참조에 대한 중복적재를 피하라

- 템플릿함수의 인자가 const 왼값참조
  - 1. 인자로 왼값
    - 복사 2번(호출자에서 함수내부로 1번, 함수내부에서 emplace할때 1번)
  - 2. 인자로 명시적 오른값 객체
    - 복사 1번(호출자에서 넘긴 오른값이 함수내부 인자인 왼값로 1번)
    - 복사가 될 수도 잇지만 이동으로 처리 가능(오른값)
  - 3. 인자로 암시적 오른값 객체
    - 복사 1번(호출자에서 넘긴 오른값이 함수내부 인자인 왼값로 1번)
    - 근데 애초에 리터럴이 emplace에 직접 전달된다면, 임시객체 생성자체가 필요 없다
- 템플릿함수의 인자가 보편참조
  - 2,3의 비효율성 제거
  - 2에서는 복사가 아닌 이동을
  - 3에서는 임시객체 생성을 애초에 안한다

### 1. 보편참조에 오버로딩의 빈번한 호출:보편참조를 사용한 오버로딩은 예상보다 자주 호출되는 상황으로 이어진다. 이는 보편참조 특성상 다양한 상황에서 매칭 될 가능성이 높기때문

- 보편참조에 대한 오버로딩을 하면?
  - `logAndAdd(T&& param)`, `logAndAdd(int idx)` 가 있을 때, `logAndAdd(short)`를 호출하면? -> `logAndAdd(T&& param)` 이게 호출되고, T는 short로 연역됨
  - 인자인 name이 short에 묶이고, forward로 인해 std::string에 short로 전달되지만, std::string 생성자에는 인자가 short인게 없다.
  - 보편참조를 받는 템플릿 함수는 c++에서 가장 욕심이 많은 함수다. -> 개발자의 예상보다 훨신 많은 인수형식을 담당하게 된다.(여기선 `logAndAdd(int idx)`가 무시됨)

### 2. 완벽전달생성자의 문제점:완벽전달생성자는 non-const 왼값에 대해 복사생성자보다 더 좋은 매칭이 된다. 이는 기본클래스의 복사,이동 생성자를 호출하려는 파생클래스의 생성자 호출을 가로챌 수 있는 문제가 있다. 완벽전달생성자가 기본클래스의 복사,이동 생성자보다 우선적으로 호출될 수 있어, 의도치 않은 동작을 유발 할 수 있다.

- 완벽전달생성자를 작성하면(**결국 주의하라는건데, 왜 작성하는거지?**)
  - 생성자의 initializer에 forward 사용(`template<typename T> Person(T&& n): name(std::forwar<T>(n))`)
  - `Person(T&&)`와 `Person(int)` 생성자가 있을 때, int 외에거 넘기면 보편참조버전이 호출되면서 실패함.
  - 위에보다 더 심각함. 컴파일러가 작성해주는 생성자들때문에
  - 어떤 함수의 호출이 템플릿인스턴스와 비템플림함수 중 비템플림함수를 우선시한다.
- 상속이 관여되면 더 심각함
  - 파생의 복사,이동에서 initializer에는 기본의 복사,이동 생성자를 호출함

위의 문제점들에 대한 해결책은 27에서 보자

## item 27. 보편참조에 대한 오버로딩 대신 사용할 수 있는 기법들을 알아두라

### 1. 보편참조와 오버로딩의 조합에 대한 대안으로는 구별되는 함수이름 사용, 매개변수를 const에 대한 좌측값 참조로 전달, 매개변수를 값으로 전달, 꼬리표 배분 사용 등이 있다.

- 오버로딩을 포기
  - 단순히 오버로딩을 포기하고, 보편참조를 받는 함수와, 아닌 함수를 이름으로 구별. 생성자는 이름이 정해져있으므로 이 방법을 적용할 수 없다.
- 매개변수를 const에 대한 좌측값 참조로 전달
  - 보편참조를 매개변수로 받는 대신, const T&를 매개변수로 받고, 오버로딩을 한다. 효율성을 포기하고 예기치 않은 문제를 피하라.
- 매개변수를 값으로 전달
  - 확실히 복사가 될 객체는 값으로 전달하라
- 꼬리표 배분 사용
  - const 좌측값 참조로 전달, 값으로 전달은 완벽한전달을 지원하지 않는다. 완벽한전달을 위해 보편참조를 쓰는거라면, 다른 대안이 없으므로 이럴 떄 꼬리표 배분을 사용한다
  - 매개변수 목록에 보편참조가 아닌 매개변수도 포함되어있으면, 보편참조가 아닌 매개변수들이 완벽하게 매칭되지 않으면, 보편참조가 오버로딩된 함수보다 우선 선택 될 수 있다.
    - logAndAdd의 호출을 다른 함수에게 위임한다(logAndAddImpl)
    - logAndAdd는 logAndAddImpl로 전달만하고, logAndAddImpl는 오버로딩한다(`logAndAddImpl(T&&, std::false_type)`, `logAndAddImpl(int, std::true_type)`)
  - 하지만, 일반함수가 아닌 생성자인 경우, 컴파일러가 자동생성한 복사생성자가 문제가 될 수 있다. 이 경우 템플릿을 제한하는 방법을 써야 함

### 2. std::enable_if 를 통해 템플릿의 인스턴스화를 제한함으로써 보편참조와 오버로딩을 함께 사용할 수 있다(std::enable_if 는 컴파일러가 보편참조를 오버로딩하는 조건을 개발자가 직접 제어)

- 보편참조를 받는 템플릿을 제한한다
  - std::enable_if 를 이용하면 컴파일러가 마치 특정 템플릿이 존재하지 않는 것처럼 행동하게 할 수 있고, 그런 템플릿을 disabled 템플릿이라 부른다.
  - 기본적으로 모든 템플릿은 enabled 상태이며, std::enable_if 를 사용하면 지정된 조건을 만족할 때만 enable 된다.
  - std::enable_if<bool>
  - std::is_same<T, U> // type 비교
  - std::decay<T> // cv 한정사 제거(const, volatile) 및 배열과 함수타입의 경우 포인터
  - std::is_base_of<Base, Derived> // Derived 가 Base 에서 파생되면 true
  - 결국 보편참조 생성자 오버로딩되는 경우가 있고, 그걸 템플릿 인스턴스에서 제외하면 되고, 그 방법은 enable_if 로 걸러내면 된다.

### 3. 보편참조 매개변수는 효율성 면에서 장점인 경우가 많지만, 대체로 사용성 면에서는 단점이 된다.

- 절충점들
  - 완벽전달에도 단점은 있다. 그 중 하나는 완벽전달이 불가능한 인수들이 있다는 점. 구체적인 타입을 받는 함수에는 전달할 수 있어도 완벽 전달은 불가능할 수 있다. 이처럼 완벽전달이 불가능한 경우는 [item 30](#item-30-완벽전달이-실패하는-경우들을-잘-알아두라)에서 알아보자
  - 또 다른 단점은 클라이언트가 유효하지 않은 인수를전달했을 때 나오는 오류메시지가 난해하다.(예제중에 있음)
  - 이러한 이유로 보편참조를 성능이 최우선 관심사인 인터페이스에만 사용하는것이 좋다고 생각하는 개발자들이 많다.
  - Person의 경우 전달함수의 보편참조 매개변수가 std::string에 대한 초기치로 쓰일것을 알고있으므로, 그런 초기치로 사용하는것이 가능한지를 미리 static_assert를 이용해 점검하는 방법도 있다.
  - std::in_constructible이라는 타입 특성은 한타입의 객체를 다른 한타입(또는 타입들의 집합)의 객체(또는 객체들의 집합)로부터 생성할 수 있는지를 컴파일 시점에서 판정한다. 이를 이용하면 assertion을 쉽게 작성할 수 있다.
    <details>
      <summary>예제</summary>

      ```cpp
      class Person {
      public:
        template<typename T>
        explicit Person(T&& n): name(std::forward<T>(n)) {
          // T 객체로부터 std::string을 생성할 수 있는지 점검한다.
          static_assert(
            std::is_constructible<std::string, T>::value,
            "Parameter n can't be used to construct a std::string"
          );
        }

      private:
        std::string name;
      };

      int main() {
        Person p1("fail");
        auto cloneOfP(p1);

        return 0;
      }
      ```
      ```bash
      ch5.cpp:180:64: error: static assertion failed: Parameter n can't be used to construct a std::string
        180 |                         std::is_constructible<std::string, T>::value,
      ```
    </details>

## item 30. 완벽전달이 실패하는 경우들을 잘 알아두라.
