- [ch5. 오른값 참조, 이동 의미론, 완벽 전달](#ch5-오른값-참조-이동-의미론-완벽-전달)
  - [그냥 사전지식?](#그냥-사전지식)
  - [item 23. std::move와 std::forward를 숙지하라](#item-23-stdmove와-stdforward를-숙지하라)
    - [1. move는 오른값으로 무조건 캐스팅한다. 이동하는게 아니다.](#1-move는-오른값으로-무조건-캐스팅한다-이동하는게-아니다)
    - [2. forward는 주어진 인수가 오른값에 묶인 경우에만, 오른값으로 캐스팅 한다.](#2-forward는-주어진-인수가-오른값에-묶인-경우에만-오른값으로-캐스팅-한다)
    - [3. move,forward 둘 다 싱핼시점에서는 아무일도 하지 않는다.](#3-moveforward-둘-다-싱핼시점에서는-아무일도-하지-않는다)
  - [item 24. 보편 참조와 오른값 참조를 구별하라](#item-24-보편-참조와-오른값-참조를-구별하라)
    - [1. 함수 템플릿 매개변수의 형식이 T\&\&이고, T가 연역된다면 또는 객체를 auto\&\&로 선언한다면 이는 보편참조이다.](#1-함수-템플릿-매개변수의-형식이-t이고-t가-연역된다면-또는-객체를-auto로-선언한다면-이는-보편참조이다)
    - [2. 형식선언의 형태가 정확히 형식\&\&가 아니면, 혹은 형식 연역이 일어나지 않는다면 이는 오른값참조다.](#2-형식선언의-형태가-정확히-형식가-아니면-혹은-형식-연역이-일어나지-않는다면-이는-오른값참조다)
    - [3. 오른값으로 초기화되는 보편참조는 오른값참조에 해당한다. 왼값으로 초기화되는 보편참조는 왼값참조에 해당한다.](#3-오른값으로-초기화되는-보편참조는-오른값참조에-해당한다-왼값으로-초기화되는-보편참조는-왼값참조에-해당한다)
  - [item 25. 오른값 참조에는 std::move를, 보편참조에는 std::forward를 사용하라](#item-25-오른값-참조에는-stdmove를-보편참조에는-stdforward를-사용하라)
    - [1. 오른값참조나 보편참조가 마지막으로 쓰이는 지점에서, 오른값참조에는 move를, 보편참조에는 forward를 사용하라](#1-오른값참조나-보편참조가-마지막으로-쓰이는-지점에서-오른값참조에는-move를-보편참조에는-forward를-사용하라)
    - [2. 결과를 값 전달하는 함수이고, 오른값참조,보편참조인 경우 move,forward를 사용하라](#2-결과를-값-전달하는-함수이고-오른값참조보편참조인-경우-moveforward를-사용하라)
    - [3. rvo가 적용될 수 있는 지역객체에는 move,forward를 적용하지 말라](#3-rvo가-적용될-수-있는-지역객체에는-moveforward를-적용하지-말라)
  - [item 26. 보편참조에 대한 중복적재를 피하라](#item-26-보편참조에-대한-중복적재를-피하라)
    - [1. 보편참조에 오버로딩의 빈번한 호출:보편참조를 사용한 오버로딩은 예상보다 자주 호출되는 상황으로 이어진다. 이는 보편참조 특성상 다양한 상황에서 매칭 될 가능성이 높기때문](#1-보편참조에-오버로딩의-빈번한-호출보편참조를-사용한-오버로딩은-예상보다-자주-호출되는-상황으로-이어진다-이는-보편참조-특성상-다양한-상황에서-매칭-될-가능성이-높기때문)
    - [2. 완벽전달생성자의 문제점:완벽전달생성자는 non-const 왼값에 대해 복사생성자보다 더 좋은 매칭이 된다. 이는 기본클래스의 복사,이동 생성자를 호출하려는 파생클래스의 생성자 호출을 가로챌 수 있는 문제가 있다. 완벽전달생성자가 기본클래스의 복사,이동 생성자보다 우선적으로 호출될 수 있어, 의도치 않은 동작을 유발 할 수 있다.](#2-완벽전달생성자의-문제점완벽전달생성자는-non-const-왼값에-대해-복사생성자보다-더-좋은-매칭이-된다-이는-기본클래스의-복사이동-생성자를-호출하려는-파생클래스의-생성자-호출을-가로챌-수-있는-문제가-있다-완벽전달생성자가-기본클래스의-복사이동-생성자보다-우선적으로-호출될-수-있어-의도치-않은-동작을-유발-할-수-있다)
  - [item 27. 보편참조에 대한 오버로딩 대신 사용할 수 있는 기법들을 알아두라](#item-27-보편참조에-대한-오버로딩-대신-사용할-수-있는-기법들을-알아두라)
    - [1. 보편참조와 오버로딩의 조합에 대한 대안으로는 구별되는 함수이름 사용, 매개변수를 const에 대한 왼값 참조로 전달, 매개변수를 값으로 전달, 꼬리표 배분 사용 등이 있다.](#1-보편참조와-오버로딩의-조합에-대한-대안으로는-구별되는-함수이름-사용-매개변수를-const에-대한-왼값-참조로-전달-매개변수를-값으로-전달-꼬리표-배분-사용-등이-있다)
    - [2. std::enable\_if 를 통해 템플릿의 인스턴스화를 제한함으로써 보편참조와 오버로딩을 함께 사용할 수 있다(std::enable\_if 는 컴파일러가 보편참조를 오버로딩하는 조건을 개발자가 직접 제어)](#2-stdenable_if-를-통해-템플릿의-인스턴스화를-제한함으로써-보편참조와-오버로딩을-함께-사용할-수-있다stdenable_if-는-컴파일러가-보편참조를-오버로딩하는-조건을-개발자가-직접-제어)
    - [3. 보편참조 매개변수는 효율성 면에서 장점인 경우가 많지만, 대체로 사용성 면에서는 단점이 된다.](#3-보편참조-매개변수는-효율성-면에서-장점인-경우가-많지만-대체로-사용성-면에서는-단점이-된다)
  - [item 28. 참조축약(collapse)을 숙지하라](#item-28-참조축약collapse을-숙지하라)
    - [1. 참조축약은 템플릿 인스턴스화, auto 타입 추론, typedef와 별칭선언의 지정 및 사용, decltype의 지정 및 사용이라는 네가지 문맥에서 일어난다.](#1-참조축약은-템플릿-인스턴스화-auto-타입-추론-typedef와-별칭선언의-지정-및-사용-decltype의-지정-및-사용이라는-네가지-문맥에서-일어난다)
    - [2. 컴파일러가 참조축약 문맥에서 참조에 대한 참조를 만들어 내면, 그 결과는 하나의 참조가 된다. 원래의 두 참조 중 하나라도 왼값 참조이면 결과는 왼값 참조이고, 그렇지 않으면 오른값 참조이다.](#2-컴파일러가-참조축약-문맥에서-참조에-대한-참조를-만들어-내면-그-결과는-하나의-참조가-된다-원래의-두-참조-중-하나라도-왼값-참조이면-결과는-왼값-참조이고-그렇지-않으면-오른값-참조이다)
    - [3. 타입추론이 왼값과 오른값을 구분하는 문맥과 참조축약이 일어나는 문맥에서 보편참조는 오른값 참조이다.](#3-타입추론이-왼값과-오른값을-구분하는-문맥과-참조축약이-일어나는-문맥에서-보편참조는-오른값-참조이다)
  - [item 29. 이동연산이 존재하지않고, 저렴하지 않고, 적용되지 않는다고 가정하라.](#item-29-이동연산이-존재하지않고-저렴하지-않고-적용되지-않는다고-가정하라)
    - [1. 이동연산들이 존재하지 않고, 저렴하지 않고, 적용되지 않을것이라고 가정하라.](#1-이동연산들이-존재하지-않고-저렴하지-않고-적용되지-않을것이라고-가정하라)
    - [2. 타임들과 이동의미론 지원여부를 미리 알 수 있는경우에는 그런 가정을 둘 필요가 없다.](#2-타임들과-이동의미론-지원여부를-미리-알-수-있는경우에는-그런-가정을-둘-필요가-없다)
  - [item 30. 완벽전달이 실패하는 경우들을 잘 알아두라.](#item-30-완벽전달이-실패하는-경우들을-잘-알아두라)
    - [1. 완벽 전달은 템플릿 타입 추론이 실패하거나, 틀린 타입을 추론했을 때 실패한다.](#1-완벽-전달은-템플릿-타입-추론이-실패하거나-틀린-타입을-추론했을-때-실패한다)
    - [2. 인수가 중괄호 초기치이거나 0 또는 NULL로 표현된 널포인터, 선어난 된 정수 static sconst 및 constexpr 데이터 멤버, 템플릿 오버로딩된 함수 이름, 비트필드이면 완벽전달이 실패한다.](#2-인수가-중괄호-초기치이거나-0-또는-null로-표현된-널포인터-선어난-된-정수-static-sconst-및-constexpr-데이터-멤버-템플릿-오버로딩된-함수-이름-비트필드이면-완벽전달이-실패한다)

# ch5. 오른값 참조, 이동 의미론, 완벽 전달

## 그냥 사전지식?

- 참조란?
  - alias, 포인터에 비해 메모리(주소저장)와 연산(주소연산)면에서 효율적
  - 수정가능성(alias이므로 원본 데이터)
  - null safe
- 오른값 참조란?
  - 말 그대로 오른값에 대한 참조로, 이동의미론과 완벽전달에 사용
  - 이동의미론은 복사대신 이동을 통한 효율성
  - 완벽전달은 인자를 완벽히 전달해 성능 및 유연성 유지
- 보편참조는?
  - 생긴건 오른값 참조처럼 &&지만, template, auto, ... 에 사용
  - lvalue, rvalue 모두 참조를 받을 수 있으므로 유연(완벽전달)
  - const vs non-const, volatile vs non-volatile 그냥 유연 그 자체
- lvalue, xvalue, rvalue
  - [참조](https://modoocode.com/294)
  - type과 value category가 있는데
  - 정체의 유무, 이동가능성으로 나눔
- 참조의 변환
  - const T&& -> const T& 가능(상수성 유지)

| x      | 이동 가능 | 이동불가능 |
| ------ | --------- | ---------- |
| 정체 o | xvalue    | lvalue     |
| 정체 x | pravlue   | 쓸모 없음  |

- decltype{표현식}은 함수처럼 쓰이고, 컴파일시 표현식에 대한 type을 반환한다
  - decltype(xavlue) -> T&&
  - decltype(lavlue) -> T&
  - decltype(ravlue) -> T

## item 23. std::move와 std::forward를 숙지하라

### 1. move는 오른값으로 무조건 캐스팅한다. 이동하는게 아니다.

- move(이동 의미론)
  - 1. 이동을 할 객체가 const면 복사하므로 이동을 보장하지않고, const로 선언하면 안된다.
    - `string(string&& rhs)`일 때, `Annotation(const std::string text): value(std::move(text)) { ... }` // string의 이동생성자가 존재할 때, text는 이동이 아닌 복사된다(const 정확성 유지를 위해)
      - text가 const 왼값이므로 std::move(text)는 const text의 오른값 참조를 반환
      - const 오른값 참조인데, 이동생성자는 오른값 참조이므로 이동생성자 호출 안됨
      - const 오른값 참조는 암시적으로 const 왼값 참조로 변환될 수 있으므로 복사생성자 호출
  - 2. 확실한건 반환값은 오른값 참조이긴 함(이동된 오른값 참조거나, 복사된 오른값 참조거나)

### 2. forward는 주어진 인수가 오른값에 묶인 경우에만, 오른값으로 캐스팅 한다.

- forward(move와 비슷하나 조건부 casting, 완벽 전달)
  - forward의 인수가 오른값으로 초기화 된 경우에만, 오른값으로 casting한다
  - 오른값으로 초기화 여부는 어떻게 아는가? 템플릿 매개변수에 부호화 되어있다.(T에대해 연역을 할때 부호화 되어있음. [item 28](#3-타입추론이-왼값과-오른값을-구분하는-문맥과-참조축약이-일어나는-문맥에서-보편참조는-오른값-참조이다))
  - **그러면 forward는 템플릿 함수 안에서만 쓸 수 있나? item28을 보자**

- 그러면 forward만 써도 되는가?
  - 가능은 하지만, 굳이? 명확성도 떨어지고 버그가능성도 높아지고?

### 3. move,forward 둘 다 싱핼시점에서는 아무일도 하지 않는다.

## item 24. 보편 참조와 오른값 참조를 구별하라

> 걍 두개 구분해라가 전부고
> 오른값참조는 이동을 위해(이동의 원본 객체 지정)
> 보편참조는 전달을 위해(전달의 원본 객체 지정?)

### 1. 함수 템플릿 매개변수의 형식이 T&&이고, T가 연역된다면 또는 객체를 auto&&로 선언한다면 이는 보편참조이다.

### 2. 형식선언의 형태가 정확히 형식&&가 아니면, 혹은 형식 연역이 일어나지 않는다면 이는 오른값참조다.

### 3. 오른값으로 초기화되는 보편참조는 오른값참조에 해당한다. 왼값으로 초기화되는 보편참조는 왼값참조에 해당한다.

- 오른값 참조
  - `void f(Widget&& param)`
  - `Widget&& var1 = Widget()`
  - `template<typename T> void f(std::vector<T>&& param)`
- 보편참조
  - `auto&& var2 = var1`
  - `template<typename T> void f(T&& param)`

- 오른값 참조
  - 이동의 원본이 될 수 있는 개체 지정
- 보편참조
  - 거의 항상 전달을 적용해야하므로 전달참조라고 부르기도 함
  - 초기값에 따라 왼값참조 혹은 오른값참조
  - 형식 연역이 일어나는 문맥이고, 단, T&& 형태여야만 한다
  - 형식연역은 호출타임에 일어난다(vector의 push_back은 이미 인스턴스화 된 시점에서 type이 고정임)

## item 25. 오른값 참조에는 std::move를, 보편참조에는 std::forward를 사용하라

- 이동 의미론과 move와 오른값참조 등장배경
  - 거대한 객체를 함수 전달시 복사는 비효율적
  - 이동이란 개념을 도입하자(move)
  - 오른값참조 등장!
- 완벽 전달과 forward와 보편참조 등장배경
  - 함수 템플릿에서 인자 전달시 원래 성질을 유지해야 함.
  - forward 이전에는 코드 복잡성 초래(std::conditional)
  - forward화 함께 보편참조 등장!

### 1. 오른값참조나 보편참조가 마지막으로 쓰이는 지점에서, 오른값참조에는 move를, 보편참조에는 forward를 사용하라

> todo: setname은 왜 보편참조를 인자로 받아야 하는가? 상수왼값참조만 있으면 되는거 아닌가? 왜 오른값 참조가 필요하지?
> 보편참조로 받으면 불필요한 복사비용을 줄일 수 있다. item 26에도 나옴

- 오른값참조를 다른 함수에 전달할 때는 move
- 보편참조를 다른 함수에 전달할 때는 forward
- forward 대신 move를 사용 할 수도 있지만, 관용적인 표현도 아니고 그렇게 해서 이득이 없다. 그냥 하지마라

- **setname은 왜 보편참조를 인자로 받아야 하는가? 상수왼값참조만 있으면 되는거 아닌가? 왜 오른값 참조가 필요하지?**
- 무튼 보편참조를 쓰면 3가지 장점
  - 유지보수 편함
  - 효율성(임시객체 생성 및 소멸)
  - 오른값일수도 왼값일수도 있는 매개변수가 무제한인 경우 overloading은 불가능. 오로지 보편참조
- move,forward로 다른 함수 인자로 주는 경우, 해당 객체를 다 쓰고 마지막에 줘야한다.

### 2. 결과를 값 전달하는 함수이고, 오른값참조,보편참조인 경우 move,forward를 사용하라

- 함수의 결과가 값을 반환한다면, move나 forward를 사용하는게 바람직하다(복사보단 이동이 낫다)

### 3. rvo가 적용될 수 있는 지역객체에는 move,forward를 적용하지 말라

- 단, 확대해석은 하지마라. move쓰면 RVO가 안되는 경우도 있다(Return Value Optimization)
  - 두가지 조건이 만족하면, 값을 반환하는 함수 호출시 복사 혹시 이동을 제거할 수 있다(copy elision)

## item 26. 보편참조에 대한 중복적재를 피하라

- 템플릿함수의 인자가 const 왼값참조
  - 1. 인자로 왼값
    - 복사 2번(호출자에서 함수내부로 1번, 함수내부에서 emplace할때 1번)
  - 2. 인자로 명시적 오른값 객체
    - 복사 1번(호출자에서 넘긴 오른값이 함수내부 인자인 왼값로 1번)
    - 복사가 될 수도 잇지만 이동으로 처리 가능(오른값)
  - 3. 인자로 암시적 오른값 객체
    - 복사 1번(호출자에서 넘긴 오른값이 함수내부 인자인 왼값로 1번)
    - 근데 애초에 리터럴이 emplace에 직접 전달된다면, 임시객체 생성자체가 필요 없다
- 템플릿함수의 인자가 보편참조
  - 2,3의 비효율성 제거
  - 2에서는 복사가 아닌 이동을
  - 3에서는 임시객체 생성을 애초에 안한다

### 1. 보편참조에 오버로딩의 빈번한 호출:보편참조를 사용한 오버로딩은 예상보다 자주 호출되는 상황으로 이어진다. 이는 보편참조 특성상 다양한 상황에서 매칭 될 가능성이 높기때문

- 보편참조에 대한 오버로딩을 하면?
  - `logAndAdd(T&& param)`, `logAndAdd(int idx)` 가 있을 때, `logAndAdd(short)`를 호출하면? -> `logAndAdd(T&& param)` 이게 호출되고, T는 short로 연역됨
  - 인자인 name이 short에 묶이고, forward로 인해 std::string에 short로 전달되지만, std::string 생성자에는 인자가 short인게 없다.
  - 보편참조를 받는 템플릿 함수는 c++에서 가장 욕심이 많은 함수다. -> 개발자의 예상보다 훨신 많은 인수형식을 담당하게 된다.(여기선 `logAndAdd(int idx)`가 무시됨)

### 2. 완벽전달생성자의 문제점:완벽전달생성자는 non-const 왼값에 대해 복사생성자보다 더 좋은 매칭이 된다. 이는 기본클래스의 복사,이동 생성자를 호출하려는 파생클래스의 생성자 호출을 가로챌 수 있는 문제가 있다. 완벽전달생성자가 기본클래스의 복사,이동 생성자보다 우선적으로 호출될 수 있어, 의도치 않은 동작을 유발 할 수 있다.

- 완벽전달생성자를 작성하면(**결국 주의하라는건데, 왜 작성하는거지?**)
  - 생성자의 initializer에 forward 사용(`template<typename T> Person(T&& n): name(std::forwar<T>(n))`)
  - `Person(T&&)`와 `Person(int)` 생성자가 있을 때, int 외에거 넘기면 보편참조버전이 호출되면서 실패함.
  - 위에보다 더 심각함. 컴파일러가 작성해주는 생성자들때문에
  - 어떤 함수의 호출이 템플릿인스턴스와 비템플림함수 중 비템플림함수를 우선시한다.
- 상속이 관여되면 더 심각함
  - 파생의 복사,이동에서 initializer에는 기본의 복사,이동 생성자를 호출함

위의 문제점들에 대한 해결책은 27에서 보자

## item 27. 보편참조에 대한 오버로딩 대신 사용할 수 있는 기법들을 알아두라

### 1. 보편참조와 오버로딩의 조합에 대한 대안으로는 구별되는 함수이름 사용, 매개변수를 const에 대한 왼값 참조로 전달, 매개변수를 값으로 전달, 꼬리표 배분 사용 등이 있다.

- 오버로딩을 포기
  - 단순히 오버로딩을 포기하고, 보편참조를 받는 함수와, 아닌 함수를 이름으로 구별. 생성자는 이름이 정해져있으므로 이 방법을 적용할 수 없다.
- 매개변수를 const에 대한 왼값 참조로 전달
  - 보편참조를 매개변수로 받는 대신, const T&를 매개변수로 받고, 오버로딩을 한다. 효율성을 포기하고 예기치 않은 문제를 피하라.
- 매개변수를 값으로 전달
  - 확실히 복사가 될 객체는 값으로 전달하라
- 꼬리표 배분 사용
  - const 왼값 참조로 전달, 값으로 전달은 완벽한전달을 지원하지 않는다. 완벽한전달을 위해 보편참조를 쓰는거라면, 다른 대안이 없으므로 이럴 떄 꼬리표 배분을 사용한다
  - 매개변수 목록에 보편참조가 아닌 매개변수도 포함되어있으면, 보편참조가 아닌 매개변수들이 완벽하게 매칭되지 않으면, 보편참조가 오버로딩된 함수보다 우선 선택 될 수 있다.
    - logAndAdd의 호출을 다른 함수에게 위임한다(logAndAddImpl)
    - logAndAdd는 logAndAddImpl로 전달만하고, logAndAddImpl는 오버로딩한다(`logAndAddImpl(T&&, std::false_type)`, `logAndAddImpl(int, std::true_type)`)
  - 하지만, 일반함수가 아닌 생성자인 경우, 컴파일러가 자동생성한 복사생성자가 문제가 될 수 있다. 이 경우 템플릿을 제한하는 방법을 써야 함

### 2. std::enable_if 를 통해 템플릿의 인스턴스화를 제한함으로써 보편참조와 오버로딩을 함께 사용할 수 있다(std::enable_if 는 컴파일러가 보편참조를 오버로딩하는 조건을 개발자가 직접 제어)

- 보편참조를 받는 템플릿을 제한한다
  - std::enable_if 를 이용하면 컴파일러가 마치 특정 템플릿이 존재하지 않는 것처럼 행동하게 할 수 있고, 그런 템플릿을 disabled 템플릿이라 부른다.
  - 기본적으로 모든 템플릿은 enabled 상태이며, std::enable_if 를 사용하면 지정된 조건을 만족할 때만 enable 된다.
  - std::enable_if<bool>
  - std::is_same<T, U> // type 비교
  - std::decay<T> // cv 한정사 제거(const, volatile) 및 배열과 함수타입의 경우 포인터
  - std::is_base_of<Base, Derived> // Derived 가 Base 에서 파생되면 true
  - 결국 보편참조 생성자 오버로딩되는 경우가 있고, 그걸 템플릿 인스턴스에서 제외하면 되고, 그 방법은 enable_if 로 걸러내면 된다.

### 3. 보편참조 매개변수는 효율성 면에서 장점인 경우가 많지만, 대체로 사용성 면에서는 단점이 된다.

- 절충점들
  - 완벽전달에도 단점은 있다. 그 중 하나는 완벽전달이 불가능한 인수들이 있다는 점. 구체적인 타입을 받는 함수에는 전달할 수 있어도 완벽 전달은 불가능할 수 있다. 이처럼 완벽전달이 불가능한 경우는 [item 30](#item-30-완벽전달이-실패하는-경우들을-잘-알아두라)에서 알아보자
  - 또 다른 단점은 클라이언트가 유효하지 않은 인수를전달했을 때 나오는 오류메시지가 난해하다.(예제중에 있음)
  - 이러한 이유로 보편참조를 성능이 최우선 관심사인 인터페이스에만 사용하는것이 좋다고 생각하는 개발자들이 많다.
  - Person의 경우 전달함수의 보편참조 매개변수가 std::string에 대한 초기치로 쓰일것을 알고있으므로, 그런 초기치로 사용하는것이 가능한지를 미리 static_assert를 이용해 점검하는 방법도 있다.
  - std::in_constructible이라는 타입 특성은 한타입의 객체를 다른 한타입(또는 타입들의 집합)의 객체(또는 객체들의 집합)로부터 생성할 수 있는지를 컴파일 시점에서 판정한다. 이를 이용하면 assertion을 쉽게 작성할 수 있다.
    <details>
      <summary>예제</summary>

      ```cpp
      class Person {
      public:
        template<typename T>
        explicit Person(T&& n): name(std::forward<T>(n)) {
          // T 객체로부터 std::string을 생성할 수 있는지 점검한다.
          static_assert(
            std::is_constructible<std::string, T>::value,
            "Parameter n can't be used to construct a std::string"
          );
        }

      private:
        std::string name;
      };

      int main() {
        Person p1("fail");
        auto cloneOfP(p1);

        return 0;
      }
      ```
      ```bash
      ch5.cpp:180:64: error: static assertion failed: Parameter n can't be used to construct a std::string
        180 |                         std::is_constructible<std::string, T>::value,
      ```
    </details>

## item 28. 참조축약(collapse)을 숙지하라

### 1. 참조축약은 템플릿 인스턴스화, auto 타입 추론, typedef와 별칭선언의 지정 및 사용, decltype의 지정 및 사용이라는 네가지 문맥에서 일어난다.

- 참조에 대한 참조는 c++에서 위법이지만, 보편참조에 대한 참조는 된다
  <details>
    <summary>예제</summary>

    - 참조에 대한 참조는 오류
      ```cpp
      int main() {
        // 오류! 참조에 대한 참조는
        // 선언할 수 없음
        int x;
        auto& &rx = x;

        return 0;
      }
      ```
    - 템플릿 인스턴스화는 축약
      ```cpp
      template <typename T>
      void func(T&& param);

      int main() {
        // func를 왼값으로 호출한다.
        // 보편참조의 초기치가 왼값이니 보편참조는 왼값참조로 추론된다. T는 Widget&
        // void func<Widget&>(Widget& && param); 로 추론되고
        // T는 Widget&로 축약된다.
        Widget w;
        func(w);

        return 0;
      }
      ```
    - auto 타입 추론
      ```cpp
      int main() {
        // 보편참조의 초기치가 왼값이니 보편참조는 왼값참조로 추론된다. type은 Widget&
        // Widget& && w1 = w;
        // type은 Widget&로 축약
        Widget w;
        auto&& w1 = w;

        return 0;
      }
      ```
    - typedef와 별칭선언의 지정 및 사용
      ```cpp
      template <typename T>
      class Widget {
      public:
        typedef T&& RvalueRefToT;
        ...
      };
      int main() {

        // 그리고 Widget을 왼값 참조 타입으로
        // 인스턴스화한다고 하자.
        Widget<int&> w;

        // Widget의 T를 int&로 대체하면
        // typedef는 다음과 같은 모습이 된다.
        typedef int& && RvalueRefToT;

        // 참조 축약(collapse)에 의해 이는 다음으로
        // 줄어든다.
        typedef int& RvalueRefToT;

        return 0;
      }
      ```
    - decltype의 지정 및 사용(item 3을 참조하라)
  </details>

### 2. 컴파일러가 참조축약 문맥에서 참조에 대한 참조를 만들어 내면, 그 결과는 하나의 참조가 된다. 원래의 두 참조 중 하나라도 왼값 참조이면 결과는 왼값 참조이고, 그렇지 않으면 오른값 참조이다.

- 참조는 왼값, 오른값 참조가 있으므로, 조합은 4가지이고, 둘다 오른값인경우만 오른값참조, 그 외에는 왼값 참조다.

### 3. 타입추론이 왼값과 오른값을 구분하는 문맥과 참조축약이 일어나는 문맥에서 보편참조는 오른값 참조이다.

- 보편참조에 대해서 왼값 인수가 전달되면 T는 왼쪽값참조로, 오른값 인수가 전달되면 T는 비참조로 추론되며, 이는 T가 추론된 타입에 따라 param이 왼값인지,오른값인지 알 수 있는 정보가 부호화 되어있음을 의미
  <details>
    <summary>예제</summary>

    ```cpp
    template <typename T>
    void func(T&& param);

    int main() {
      // 우측값을 돌려주는 함수
      Widget widgetFactory();

      // 변수(좌측값)
      Widget w;

      // func를 좌측값으로 호출한다;
      // T는 Widget&로 추론된다.
      func(w);

      // func를 우측값으로 호출한다;
      // T는 Widget으로 추론된다.
      func(widgetFactory());

      return 0;
    }
    ```
  </details>
- std::forward가 작동하는 것은 참조축약 덕분이다
  <details>
    <summary>예제</summary>

    ```cpp
    //-----------------------------------------------------------------------------
    // std::forward 함수의 일반적인 용례는
    // 다음과 같은 모습이다.

    template <typename T>
    void f(T&& fParam)
    {
      ...									// 어떤 작업을 수행

      someFunc(std::forward<T>(fParam));	// fParam을
    }										// someFunc로 전달

    // std::forward는 대략 다음과 같이 생겼을
    // 것이다. 이것은 완벽히 정확한 구현은 아니지만,
    // std::forward의 작동 방식을 이해하는
    // 목적으로는 충분하다.

    template <typename T>									// 이름공간
    T&& forward(typename remove_reference<T>::type& param)	// std 안에서
    {
      return static_cast<T&&>(param);
    }


    //-----------------------------------------------------------------------------
    // f에 전달된 인수가 Widget
    // 타입의 좌측값이라고 하자.

    // 그러면 T는 Widget&로 추론되며,
    // std::forward 호출은 std::forward<Widget&>
    // 형태로 인스턴스화된다.

    // Widget&를 std::forward의 구현에 대입하면
    // 다음과 같은 코드가 나온다.

    Widget& && forward(typename remove_reference<Widget&>::type& param)
    {
      return static_cast<Widget& &&>(param);
    }

    // 타입 특성 std::remove_reference<Widget&>::type은
    // Widget을 산출하므로, std::forward는 다음이 된다.

    Widget& && forward(Widget& param)
    {
      return static_cast<Widget& &&>(param);
    }

    // 참조 축약(collapse)은 반환 타입과 캐스팅에도 적용된다.
    // 참조 축약(collapse)까지 적용한 최종 버전은 다음과 같이 된다.

    Widget& forward(Widget& param)				// 여전히 이름공간
    {											// std 안에서
      return static_cast<Widget&>(param);
    }

    // 이 예에서 보듯이, 좌측값 인수가 전달되면
    // std::forward는 좌측값 참조를 돌려준다.


    //-----------------------------------------------------------------------------
    // f에 전달된 인수가 Widget 타입의 우측값일
    // 때에는 어떻게 될까?

    // 이 경우 f의 타입 매개변수 T에 대해 추론되는
    // 타입은 그냥 Widget이다.

    // 따라서 f 내부의 std::forward 호출은
    // std::forward<Widget>으로 인스턴스화된다.

    // std::forward의 구현에서 T를 Widget으로
    // 대체하면 다음과 같은 모습이 된다.

    Widget&& forward(typename remove_reference<Widget>::type& param)
    {
      return static_cast<Widget&&>(param);
    }

    // std::remove_reference를 비참조 타입 Widget에
    // 적용하면 애초의 타입(Widget)이 산출되므로, std::forward는
    // 다음이 된다.

    Widget&& forward(Widget& param)
    {
      return static_cast<Widget&&>(param);
    }

    // 여기에는 참조에 대한 참조가 없으므로 참조 축약(collapse)도 없다.
    // 이것이 이 호출에 대한 std::forward 인스턴스의 최종
    // 버전이다.

    // 정리하자면, f에 전달된 우측값 인수는 하나의
    // 우측값으로써 someFunc에 전달되며, 이 역시 마땅히
    // 그래야 하는 결과이다.


    //-----------------------------------------------------------------------------
    // C++14에서는 std::remove_reference_t 덕분에
    // std::forward를 좀 더 간결하게 구현할 수 있다.

    template <typename T>						// C++14; 역시
    T&& forward(remove_reference_t<T>& param)	// 이름공간 std
    {											// 안에서
      return static_cast<T&&>(param);
    }
    ```
  </details>

## item 29. 이동연산이 존재하지않고, 저렴하지 않고, 적용되지 않는다고 가정하라.

### 1. 이동연산들이 존재하지 않고, 저렴하지 않고, 적용되지 않을것이라고 가정하라.

### 2. 타임들과 이동의미론 지원여부를 미리 알 수 있는경우에는 그런 가정을 둘 필요가 없다.

## item 30. 완벽전달이 실패하는 경우들을 잘 알아두라.

### 1. 완벽 전달은 템플릿 타입 추론이 실패하거나, 틀린 타입을 추론했을 때 실패한다.

### 2. 인수가 중괄호 초기치이거나 0 또는 NULL로 표현된 널포인터, 선어난 된 정수 static sconst 및 constexpr 데이터 멤버, 템플릿 오버로딩된 함수 이름, 비트필드이면 완벽전달이 실패한다.
